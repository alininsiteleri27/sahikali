
// ========================================
// 2048 GAME ENGINE
// ========================================
class Game2048 {
    constructor(betAmount) {
        this.grid = Array(4).fill().map(() => Array(4).fill(0));
        this.score = 0;
        this.betAmount = betAmount;
        this.gameOver = false;
        this.hasWon = false;
        this.bestScore = parseInt(localStorage.getItem('bestScore2048')) || 0;
        
        this.gridContainer = document.getElementById('grid2048');
        this.scoreEl = document.getElementById('score2048');
        this.bestScoreEl = document.getElementById('bestScore2048');
        
        this.bestScoreEl.textContent = this.bestScore;
        this.scoreEl.textContent = 0;
        document.getElementById('result2048').className = 'game-result';
        document.getElementById('result2048').textContent = '';
        
        this.addRandomTile();
        this.addRandomTile();
        this.render();
        this.setupInput();
    }
    
    addRandomTile() {
        const emptyCells = [];
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                if (this.grid[r][c] === 0) emptyCells.push({r, c});
            }
        }
        
        if (emptyCells.length > 0) {
            const {r, c} = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            this.grid[r][c] = Math.random() < 0.9 ? 2 : 4;
            return {r, c, val: this.grid[r][c]};
        }
        return null;
    }
    
    render() {
        this.gridContainer.innerHTML = '';
        
        // Background grid cells
        for (let i = 0; i < 16; i++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            this.gridContainer.appendChild(cell);
        }
        
        // Tiles
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                const val = this.grid[r][c];
                if (val > 0) {
                    const tile = document.createElement('div');
                    tile.className = `tile tile-${val} tile-position-${r}-${c}`;
                    if (val > 2048) tile.classList.add('tile-2048'); // 2048+ aynÄ± stil
                    tile.textContent = val;
                    this.gridContainer.appendChild(tile);
                }
            }
        }
        
        this.scoreEl.textContent = this.score;
        
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            this.bestScoreEl.textContent = this.bestScore;
            localStorage.setItem('bestScore2048', this.bestScore);
        }
    }
    
    move(direction) {
        if (this.gameOver) return;
        
        let moved = false;
        const newGrid = JSON.parse(JSON.stringify(this.grid));
        
        // Logic for sliding and merging
        const slide = (row) => {
            const arr = row.filter(val => val);
            const missing = 4 - arr.length;
            const zeros = Array(missing).fill(0);
            return arr.concat(zeros);
        };
        
        const merge = (row) => {
            for (let i = 0; i < 3; i++) {
                if (row[i] !== 0 && row[i] === row[i + 1]) {
                    row[i] *= 2;
                    row[i + 1] = 0;
                    this.score += row[i];
                    
                    if (row[i] === 2048 && !this.hasWon) {
                        this.hasWon = true;
                        this.gameWin();
                    }
                }
            }
            return row;
        };
        
        if (direction === 'left' || direction === 'right') {
            for (let r = 0; r < 4; r++) {
                let row = newGrid[r];
                if (direction === 'right') row.reverse();
                
                row = slide(row);
                row = merge(row);
                row = slide(row);
                
                if (direction === 'right') row.reverse();
                
                if (JSON.stringify(this.grid[r]) !== JSON.stringify(row)) moved = true;
                newGrid[r] = row;
            }
        } else if (direction === 'up' || direction === 'down') {
            for (let c = 0; c < 4; c++) {
                let col = [newGrid[0][c], newGrid[1][c], newGrid[2][c], newGrid[3][c]];
                if (direction === 'down') col.reverse();
                
                col = slide(col);
                col = merge(col);
                col = slide(col);
                
                if (direction === 'down') col.reverse();
                
                for (let r = 0; r < 4; r++) {
                    if (newGrid[r][c] !== col[r]) moved = true;
                    newGrid[r][c] = col[r];
                }
            }
        }
        
        if (moved) {
            this.grid = newGrid;
            this.addRandomTile();
            this.render();
            
            if (this.checkGameOver()) {
                this.gameOver = true;
                this.gameLose();
            }
        }
    }
    
    checkGameOver() {
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                if (this.grid[r][c] === 0) return false;
                if (r < 3 && this.grid[r][c] === this.grid[r + 1][c]) return false;
                if (c < 3 && this.grid[r][c] === this.grid[r][c + 1]) return false;
            }
        }
        return true;
    }
    
    async gameWin() {
        // 2048'e ulaÅŸtÄ±!
        // Devam etmesine izin ver ama Ã¶dÃ¼lÃ¼ ver.
        // Tek seferlik Ã¶dÃ¼l.
        const userRef = doc(db, 'users', currentUser.uid);
        const winAmount = this.betAmount * 10;
        
        await updateDoc(userRef, {
            score: increment(winAmount)
        });
        
        showGameResult('result2048', `ðŸŽ‰ TEBRÄ°KLER! 2048'e ulaÅŸtÄ±n! +${winAmount} Puan`, 'win');
        // Oyunu bitirme, devam edebilir (score kasmak iÃ§in)
    }
    
    async gameLose() {
        showGameResult('result2048', 'Oyun Bitti!', 'lose');
    }
    
    setupInput() {
        // Remove old listeners to prevent duplication
        const newBody = document.body.cloneNode(true);
        // This approach is too aggressive, better to use a flag or named function
        // But for simplicity in this context:
        
        document.onkeydown = (e) => {
            if (document.getElementById('game2048Modal').style.display === 'none') return;
            
            if (e.key === 'ArrowLeft') this.move('left');
            else if (e.key === 'ArrowRight') this.move('right');
            else if (e.key === 'ArrowUp') this.move('up');
            else if (e.key === 'ArrowDown') this.move('down');
        };
        
        // Touch events
        let touchStartX = 0;
        let touchStartY = 0;
        const gameContainer = document.querySelector('.game-2048-container');
        
        gameContainer.ontouchstart = (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        };
        
        gameContainer.ontouchend = (e) => {
            if (!touchStartX || !touchStartY) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const diffX = touchStartX - touchEndX;
            const diffY = touchStartY - touchEndY;
            
            if (Math.abs(diffX) > Math.abs(diffY)) {
                if (diffX > 0) this.move('left');
                else this.move('right');
            } else {
                if (diffY > 0) this.move('up');
                else this.move('down');
            }
            
            touchStartX = 0;
            touchStartY = 0;
            e.preventDefault();
        };
    }
}

let game2048 = null;

document.getElementById('game2048Card').addEventListener('click', () => {
    document.getElementById('game2048Modal').style.display = 'flex';
});

document.getElementById('restart2048Btn').addEventListener('click', async () => {
    const betAmount = parseInt(document.getElementById('bet2048Amount').value);
    
    if (betAmount < 20) {
        showGameResult('result2048', 'Minimum bahis 20!', 'lose');
        return;
    }
    
    const userRef = doc(db, 'users', currentUser.uid);
    const userSnap = await getDoc(userRef);
    const currentScore = userSnap.data().score;
    
    if (currentScore < betAmount) {
        showGameResult('result2048', 'Yetersiz bakiye!', 'lose');
        return;
    }
    
    await updateDoc(userRef, {
        score: increment(-betAmount)
    });
    
    game2048 = new Game2048(betAmount);
});
